import numpy
import typing

from . import base


class OnceOffEventAuxiliarySolver(base.AuxiliarySolver):
    """
    A once off event generator generators a single
    observable event once, of some type u in U and
    at some time t in T.

    Suppose there are T different time periods and
    U possible event types. Then the prior probability
    of a once-off event generator generating an event
    at a particular time t with particular type u is
    1 / (|T| * |U|)
    """

    def __init__(self):
        self.banned_ids = set()

    def exclude(self, solution: base.AuxiliarySolution):
        self.banned_ids.add(solution.id)

    def solve(self, problem: base.AuxiliaryProblem) -> typing.Optional[base.AuxiliarySolution]:

        T = len(problem.times)
        U = len(problem.event_types)
        log_prior_prob = -numpy.log(T) -numpy.log(U)

        prizes = numpy.copy(problem.prizes)
        # Constrain to prevent picking banned solutions again
        for soln_id in self.banned_ids:
            # ugh. fix this awfulness.
            st, su = soln_id.split(';')
            t = int(st)
            u = int(su)
            prizes[(t, u)] = -numpy.inf

        # Find once off event parameters (t, u) that maximise objective function.
        i = numpy.argmax(prizes)
        t, u = numpy.unravel_index(i, shape=prizes.shape)

        # note: Once-off event generator is deterministic so log P(E=e|T=t, U=u) = log 1 = 0
        objective = prizes[(t, u)] + log_prior_prob

        # The events generated by our generator is a single event at T=t of type U=u
        e = numpy.zeros(shape=prizes.shape, dtype=numpy.uint)
        e[(t, u)] = 1

        if numpy.isfinite(objective):
            return base.AuxiliarySolution(
                id='%d;%d' % (t, u),
                objective=objective,
                logprob=log_prior_prob,
                e=e,
            )
        else:
            return None