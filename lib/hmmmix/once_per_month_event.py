import numpy
import typing

from . import base


class OncePerMonthEventAuxiliarySolver(base.AuxiliarySolver):
    """
    A once per month event generator generators a single
    observable event once every month (on a random day),
    of some type u in U and at some time t in T.

    need to consider:
    *   month duration (30)
    *   phase
    *   random day in each month
    """

    def __init__(self):
        self.banned_ids = set()

    def exclude(self, solution: base.AuxiliarySolution):
        self.banned_ids.add(solution.id)

    def solve(self, problem: base.AuxiliaryProblem) -> typing.Optional[base.AuxiliarySolution]:
        month_duration = 30
        T = len(problem.times)
        U = len(problem.event_types)
        n_phases = 1.0 * month_duration

        log_prior_prob = -numpy.log(U) - numpy.log(n_phases)

        max_objective = -numpy.inf
        max_logprob = None
        max_description = None
        max_e = None

        for u in problem.event_types:
            for phase in range(month_duration):
                acc_objective = log_prior_prob
                acc_logprob = log_prior_prob

                trajectory = []
                # The events generated by our generator
                e = numpy.zeros(shape=problem.prizes.shape, dtype=numpy.uint)

                for month_start in range(-phase, T, month_duration):
                    month_start = max(0, month_start)
                    month_end = min(month_start + month_duration, T)
                    month_prizes = problem.prizes[month_start:month_end, u]
                    # Since probability of generating an event on any day in
                    # month is uniform, maximise this part of objective func by
                    # simpling generating event on any day of month with maximal prize.
                    i_star = numpy.argmax(month_prizes)
                    t_star = month_start + i_star
                    e[(t_star, u)] += 1

                    prize = month_prizes[i_star]

                    # there was a good chance we generated event on some other day
                    # since we don't assume pattern on any particular day of month.
                    log_prob_emit_on_tstar = -numpy.log(month_duration)

                    acc_objective += prize + log_prob_emit_on_tstar
                    acc_logprob += log_prob_emit_on_tstar

                    trajectory.append(i_star)

                if acc_objective <= max_objective:
                    continue

                candidate_description = 'phase=%d;u=%d;trajectory=%r' % (
                    phase,
                    u,
                    trajectory,
                )
                if candidate_description in self.banned_ids:
                    continue

                max_objective = acc_objective
                max_logprob = acc_logprob
                max_e = e
                max_description = candidate_description

        if max_description is None:
            return None

        return base.AuxiliarySolution(
            id=max_description,
            objective=max_objective,
            logprob=max_logprob,
            e=max_e,
        )